module;

#include <cstddef>

#ifndef USE_IMPORT_STD
#include <cmath>
#include <utility>
#include <concepts>
#include <stdexcept>
#endif

export module linal:matrix;

#ifdef USE_IMPORT_STD
import std;
#endif

import :vector;
import :config;

namespace linal {

export
template<typename T>
class Matrix {
public:
  Matrix(size_t rows, size_t cols, const T& val = T{}) {
    data_.resize(rows);
    for (size_t i{0}; i < rows; ++i) {
      data_[i].reserve(cols);
      for (size_t j{0}; j < cols; ++j) { data_[i].push(val); }
    }
  }

  template<typename FwdIt>
  Matrix(size_t rows, size_t cols, FwdIt start, FwdIt finish) {
    data_.resize(rows);
    for (size_t i{0}; i < rows; ++i) {
      data_[i].reserve(cols);
      for (size_t j{0}; j < cols; ++j) {
        if (start != finish) {
          data_[i].push(*start);
          ++start;          
        } else {
          data_[i].push(T{});
        }
      }
    }
  }
  
  const Vector<T>& operator[](size_t idx) const noexcept {
    return data_[idx];
  }
  
  Vector<T>& operator[](size_t idx) noexcept {
    return const_cast<Vector<T>&>(static_cast<const Matrix&>(*this)[idx]);
  }

  [[nodiscard]] 
  size_t nrows() const {
    return data_.size();
  }

  [[nodiscard]] 
  size_t ncols() const {
    if (data_.empty()) { return 0; }
    return data_[0].size();
  }

  [[nodiscard]] 
  bool is_square() const {
    if (data_.empty()) { return true; }
    return nrows() == ncols();
  }

  [[nodiscard]]
  double determinant() const requires std::floating_point<T> {
    size_t n = nrows();
    if (n == 0) { 
      throw std::logic_error("The matrix should not be empty for determinant()");
    }
    if (!is_square()) {
      throw std::logic_error("Matrix must be square for determinant()");
    }

    Matrix<T> tmp(*this);
    double det{1.0};
    int sign{1};

    for (size_t i = 0; i < n; ++i) {
      size_t pivot = i;
      double max_val = std::abs(tmp[pivot][i]);
      for (size_t j = i + 1; j < n; ++j) {
        double v = std::abs(tmp[j][i]);
        if (v > max_val) {
          max_val = v;
          pivot = j;
        }
      }

      if (max_val < EPS) { return 0.0; }

      if (pivot != i) {
        std::swap(tmp[i], tmp[pivot]);
        sign *= -1;
      }

      const T diag = tmp[i][i];
      for (size_t j = i + 1; j < n; ++j) {
        const double factor = tmp[j][i] / diag;
        tmp[j][i] = 0.0;

        for (size_t k = i + 1; k < n; ++k) {
          tmp[j][k] -= factor * tmp[i][k];
        }
      }
      det *= diag;
    }

    return det * sign;
  }

  [[nodiscard]]
  int determinant() const requires std::integral<T> {
    size_t n = nrows();
    if (n == 0) {
      throw std::logic_error("The matrix should not be empty for determinant()");
    }
    if (!is_square()) {
      throw std::logic_error("Matrix must be square for determinant()");
    }

    Matrix tmp(*this);

    int sign{1};
    int prev_diag = 1;
    for (size_t i = 0; i < n - 1; ++i) {
      size_t pivot = i;
      int max_val = std::abs(tmp[pivot][i]);
      for (size_t j = i + 1; j < n; ++j) {
          int v = std::abs(tmp[j][i]);
          if (v > max_val) {
              max_val = v;
              pivot = j;
          }
      }
      if (max_val == 0) { return 0; }

      if (pivot != i) {
        std::swap(tmp[i], tmp[pivot]);
        sign *= -1;
      }

      const int diag = tmp[i][i];
      for (size_t j = i + 1; j < n; ++j) {
        for (size_t k = i + 1; k < n; ++k) {
          tmp[j][k] = (tmp[j][k] * diag - tmp[j][i] * tmp[i][k]) / prev_diag;
        }
      }
      prev_diag = diag;
    }
    return tmp[n - 1][n - 1] * sign;
  }

private:
  Vector<Vector<T>> data_;
};
  
} // namespace linal
